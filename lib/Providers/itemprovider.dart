import 'package:firebase_database/firebase_database.dart';
import 'package:flutter/material.dart';

import '../Models/itemmodel.dart';

class ItemProvider with ChangeNotifier {
  final databaseRef = FirebaseDatabase.instance.ref().child('items');

  List<Item> _items = [];
  List<Item> get items => _items;


  //
  // Future<void> addItem({
  //   required String id,
  //   required String itemName,
  //   required double purchasePrice,
  //   required double salePrice,
  //   required double tax,
  //   required double netPrice,
  //   required String barcode,
  //   required String unit,
  //   required int quantity,
  //   required String expiryDate,
  //   required String managerId, // Add manager ID
  // }) async {
  //   await databaseRef.push().set({
  //     "itemId": id,
  //     "item_name": itemName,
  //     "purchase_price": purchasePrice,
  //     "sale_price": salePrice,
  //     "tax": tax,
  //     "net_price": netPrice,
  //     "barcode": barcode,
  //     "unit": unit,
  //     "quantity": quantity,
  //     "expiry_date": expiryDate,
  //     "manager_id": managerId, // Save manager ID
  //   });
  //
  //   notifyListeners(); // Notify listeners about the change
  // }
// Update existing item in the database

  Future<void> addItem({
    required String itemName,
    required double purchasePrice,
    required double salePrice,
    required double tax,
    required double netPrice,
    required String barcode,
    required String unit,
    required int quantity,
    required String expiryDate,
    required String managerId,
    required String brandName,
    required double taxamount,
    required int total_pieces_per_box,
    required double ratePerTab,
  }) async {
    // Get a new reference with a unique key
    final newItemRef = databaseRef.push();

    // Use the key (itemId) generated by Firebase
    final itemId = newItemRef.key;
    double taxamount = (salePrice * 18) / 100;

    // Save the item data to Firebase using the generated itemId
    await newItemRef.set({
      "item_id": itemId, // Save the item ID
      "item_name": itemName,
      "purchase_price": purchasePrice,
      "sale_price": salePrice,
      "tax": tax,
      "net_price": netPrice,
      "barcode": barcode,
      "unit": unit,
      "quantity": quantity,
      "expiry_date": expiryDate,
      "manager_id": managerId,
      "brand_name": brandName,
      "tax_amount":taxamount,
      "total_pieces_per_box":total_pieces_per_box,
      "ratePerTab" : ratePerTab
    });

    // Optionally update the local _items list
    _items.add(Item(
      id: itemId!,
      itemName: itemName,
      purchasePrice: purchasePrice,
      salePrice: salePrice,
      tax: tax,
      netPrice: netPrice,
      barcode: barcode,
      unit: unit,
      quantity: quantity,
      expiryDate: expiryDate,
      managerId: managerId,
      taxamount: taxamount,
      brandName: brandName,
      total_pieces_per_box: total_pieces_per_box,
        ratePerTab: ratePerTab

    ));

    notifyListeners(); // Notify listeners about the change
  }







  Future<void> updateItem({
    required String itemId,
    required String itemName,
    required double purchasePrice,
    required double salePrice,
    required double tax,
    required double netPrice,
    required String barcode,
    required String unit,
    required int quantity,
    required String expiryDate,
    required String managerId,
    required String brandName,
    required double taxamount,
    required int total_pieces_per_box,
    required double ratePerTab
  }) async {
    // Find the item in the list and update it locally
    final index = _items.indexWhere((item) => item.id == itemId);
    if (index != -1) {
      // Update local list
      _items[index] = Item(
        id: itemId,
        itemName: itemName,
        purchasePrice: purchasePrice,
        salePrice: salePrice,
        tax: tax,
        netPrice: netPrice,
        barcode: barcode,
        unit: unit,
        quantity: quantity,
        expiryDate: expiryDate,
        managerId: managerId,
        brandName: brandName,
        taxamount: taxamount,
        total_pieces_per_box : total_pieces_per_box,
        ratePerTab:ratePerTab
      );

      // Update the item in Firebase using item_id node
      await databaseRef.child(itemId).update({
        "item_id": itemId, // Ensure item_id is updated if necessary
        "item_name": itemName,
        "purchase_price": purchasePrice,
        "sale_price": salePrice,
        "tax": tax,
        "net_price": netPrice,
        "barcode": barcode,
        "unit": unit,
        "quantity": quantity,
        "expiry_date": expiryDate,
        "manager_id": managerId, // Update the manager ID
        "brand_name":brandName,
        "tax_amount":taxamount,
        "total_pieces_per_box": total_pieces_per_box,
        "ratePerTab":ratePerTab
      });

      notifyListeners(); // Notify listeners that data has changed
    }
  }


  Future<void> fetchItems() async {
    try {
      print("NEW");
      final snapshot = await databaseRef.get();
      if (snapshot.exists) {
        final Map<dynamic, dynamic>? data = snapshot.value as Map<dynamic, dynamic>?;
        if (data != null) {
          _items = data.entries.map((entry) {
            return Item.fromFirebase(entry.key, entry.value);
          }).toList();
        }
      }
      notifyListeners();
    } catch (error) {
      print("Failed to load items: $error");
    }
  }

  Future<void> deleteItem(String itemId) async {
    try {
      // Delete the item from Firebase using its itemId
      await databaseRef.child(itemId).remove();

      // Also remove the item locally from the _items list
      _items.removeWhere((item) => item.id == itemId);

      notifyListeners(); // Notify listeners that an item has been deleted
    } catch (error) {
      print("Failed to delete item: $error");
    }
  }


  Future<bool> isDuplicateItem({
    required String itemName,
    required String barcode,
    String? itemId,
  }) async {
    // Ensure the latest items are fetched from the database
    await fetchItems();

    // Now use the locally stored _items for the duplication check
    return _items.any((item) =>
    (item.itemName == itemName || item.barcode == barcode) &&
        (itemId == null || item.id != itemId));
  }


}
